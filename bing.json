/*
Bingç§¯åˆ†å®Œæ•´ä¼˜åŒ–ç‰ˆ v4.0
æ•´åˆlowkingå’Œmcdashengè„šæœ¬ä¼˜ç‚¹
æ”¯æŒPCç«¯ã€ç§»åŠ¨ç«¯ã€Edgeç«¯æœç´¢ + ç§¯åˆ†ä»»åŠ¡
*/

const $ = new Toolkit("Bingç§¯åˆ†ä¼˜åŒ–ç‰ˆ", "BingPoint", {
  httpApi: "ffff@10.0.0.19:6166"
});

// BoxJSé…ç½®é”®å
const CONFIG = {
  // åŸºç¡€é…ç½®
  RESET_HOURS: 'bingResetHours',
  SCRIPT_TIMEOUT: 'bingScriptTimeout',
  
  // Cookieé…ç½®
  POINT_COOKIE: 'bingPointCookie',
  PC_COOKIE: 'bingSearchCookiePC', 
  MOBILE_COOKIE: 'bingSearchCookieMobile',
  
  // æœç´¢æ¬¡æ•°é…ç½®
  PC_SEARCH_COUNT: 'bingPcSearchCount',
  MOBILE_SEARCH_COUNT: 'bingMobileSearchCount',
  EDGE_SEARCH_COUNT: 'bingEdgeSearchCount',
  
  // é«˜çº§é…ç½®
  USE_CN_DOMAIN: 'bingUseCnDomain',
  SEARCH_INTERVAL: 'bingSearchInterval',
  ENABLE_DEBUG: 'bingEnableDebug'
};

const scriptTimeout = $.getVal(CONFIG.SCRIPT_TIMEOUT) || 30;

// ä»BoxJSè¯»å–é…ç½®
const config = {
  resetHours: $.getVal(CONFIG.RESET_HOURS) || 8,
  pointCookie: $.getVal(CONFIG.POINT_COOKIE),
  pcCookie: $.getVal(CONFIG.PC_COOKIE),
  mobileCookie: $.getVal(CONFIG.MOBILE_COOKIE),
  pcSearchCount: $.getVal(CONFIG.PC_SEARCH_COUNT) || 30,
  mobileSearchCount: $.getVal(CONFIG.MOBILE_SEARCH_COUNT) || 20,
  edgeSearchCount: $.getVal(CONFIG.EDGE_SEARCH_COUNT) || 10,
  useCnDomain: $.getVal(CONFIG.USE_CN_DOMAIN) !== "false",
  searchInterval: $.getVal(CONFIG.SEARCH_INTERVAL) || 5,
  enableDebug: $.getVal(CONFIG.ENABLE_DEBUG) === "true"
};

// çŠ¶æ€è®°å½•
const STATE = {
  LAST_EXEC_DATE: 'bingLastExecDate',
  PC_SEARCH_TODAY: 'bingPcSearchToday',
  MOBILE_SEARCH_TODAY: 'bingMobileSearchToday', 
  EDGE_SEARCH_TODAY: 'bingEdgeSearchToday',
  CACHE_POINTS: 'bingCachePoints'
};

let todayString = $.formatDate(new Date(), 'yyyyMMdd');
let searchState = {
  pc: {
    count: $.getVal(STATE.PC_SEARCH_TODAY) || 0,
    total: config.pcSearchCount
  },
  mobile: {
    count: $.getVal(STATE.MOBILE_SEARCH_TODAY) || 0, 
    total: config.mobileSearchCount
  },
  edge: {
    count: $.getVal(STATE.EDGE_SEARCH_TODAY) || 0,
    total: config.edgeSearchCount
  }
};

// ä¸»æ‰§è¡Œå‡½æ•°
if (!$.isExecComm) {
  if ($.isRequest()) {
    getCookie();
    $.done();
  } else {
    setupBoxJS();
    executeBingTasks();
  }
}

function setupBoxJS() {
  $.boxJsJsonBuilder({
    "icons": [
      "https://raw.githubusercontent.com/lowking/Scripts/master/doc/icon/bingPoint.png",
      "https://raw.githubusercontent.com/lowking/Scripts/master/doc/icon/bingPoint.png"
    ],
    "settings": [
      // åŸºç¡€è®¾ç½®
      {
        "id": CONFIG.RESET_HOURS,
        "name": "æ¯æ—¥ä»»åŠ¡é‡ç½®æ—¶é—´(å°æ—¶)",
        "val": 8,
        "type": "number",
        "desc": "è®¾ç½®æ¯å¤©å‡ ç‚¹é‡ç½®ä»»åŠ¡ï¼Œ24å°æ—¶åˆ¶"
      },
      {
        "id": CONFIG.USE_CN_DOMAIN,
        "name": "ä½¿ç”¨å›½åŒºåŸŸå",
        "val": true,
        "type": "boolean", 
        "desc": "å¼€å¯ä½¿ç”¨cn.bing.comï¼Œå…³é—­ä½¿ç”¨www.bing.com"
      },
      
      // Cookieé…ç½®
      {
        "id": CONFIG.POINT_COOKIE,
        "name": "Bingç§¯åˆ†Cookie",
        "val": "",
        "type": "text",
        "desc": "è®¿é—®rewards.bing.comè·å–çš„Cookie"
      },
      {
        "id": CONFIG.PC_COOKIE,
        "name": "PCç«¯æœç´¢Cookie",
        "val": "",
        "type": "text",
        "desc": "åœ¨PCæµè§ˆå™¨è®¿é—®bing.comè·å–çš„Cookie"
      },
      {
        "id": CONFIG.MOBILE_COOKIE, 
        "name": "ç§»åŠ¨ç«¯æœç´¢Cookie",
        "val": "",
        "type": "text",
        "desc": "åœ¨æ‰‹æœºæµè§ˆå™¨è®¿é—®bing.comè·å–çš„Cookie"
      },
      
      // æœç´¢æ¬¡æ•°é…ç½®
      {
        "id": CONFIG.PC_SEARCH_COUNT,
        "name": "PCç«¯æœç´¢æ¬¡æ•°",
        "val": 30,
        "type": "number",
        "desc": "PCç«¯æ¯æ—¥æœç´¢æ¬¡æ•°ï¼Œå»ºè®®30æ¬¡"
      },
      {
        "id": CONFIG.MOBILE_SEARCH_COUNT,
        "name": "ç§»åŠ¨ç«¯æœç´¢æ¬¡æ•°", 
        "val": 20,
        "type": "number",
        "desc": "ç§»åŠ¨ç«¯æ¯æ—¥æœç´¢æ¬¡æ•°ï¼Œå»ºè®®20æ¬¡"
      },
      {
        "id": CONFIG.EDGE_SEARCH_COUNT,
        "name": "Edgeç«¯æœç´¢æ¬¡æ•°",
        "val": 10,
        "type": "number",
        "desc": "Edgeæµè§ˆå™¨æœç´¢æ¬¡æ•°"
      },
      
      // é«˜çº§è®¾ç½®
      {
        "id": CONFIG.SEARCH_INTERVAL,
        "name": "æœç´¢é—´éš”(ç§’)",
        "val": 5,
        "type": "number",
        "desc": "æ¯æ¬¡æœç´¢ä¹‹é—´çš„é—´éš”æ—¶é—´"
      },
      {
        "id": CONFIG.SCRIPT_TIMEOUT,
        "name": "è„šæœ¬è¶…æ—¶æ—¶é—´(ç§’)",
        "val": 30,
        "type": "number",
        "desc": "è„šæœ¬æ‰§è¡Œæœ€å¤§æ—¶é—´"
      },
      {
        "id": CONFIG.ENABLE_DEBUG,
        "name": "å¼€å¯è°ƒè¯•æ—¥å¿—",
        "val": false,
        "type": "boolean",
        "desc": "æ˜¾ç¤ºè¯¦ç»†æ‰§è¡Œæ—¥å¿—"
      }
    ],
    "keys": [CONFIG.POINT_COOKIE],
    "script_timeout": scriptTimeout
  }, {
    "script_url": "https://github.com/lowking/Scripts/blob/master/bing/bingPoint.js",
    "author": "@lowking & @mcdasheng",
    "repo": "https://github.com/lowking/Scripts",
  });
}

async function executeBingTasks() {
  if (!checkResetCondition()) {
    $.log("â° ä»Šæ—¥ä»»åŠ¡å·²å®Œæˆï¼Œè·³è¿‡æ‰§è¡Œ");
    await showCurrentPoints();
    return;
  }
  
  $.log("ğŸ¯ å¼€å§‹æ‰§è¡ŒBingç§¯åˆ†ä»»åŠ¡");
  
  let totalPoints = 0;
  let taskResults = {
    points: 0,
    pc: 0, 
    mobile: 0,
    edge: 0
  };
  
  // æ‰§è¡Œç§¯åˆ†ä»»åŠ¡
  if (config.pointCookie) {
    $.log("\nğŸ“‹ å¼€å§‹ç§¯åˆ†ä»»åŠ¡...");
    taskResults.points = await executePointTasks();
    totalPoints += taskResults.points;
  }
  
  // æ‰§è¡Œæœç´¢ä»»åŠ¡
  if (config.pcCookie) {
    $.log("\nğŸ’» å¼€å§‹PCç«¯æœç´¢...");
    taskResults.pc = await executeSearch('pc');
    totalPoints += taskResults.pc;
  }
  
  if (config.mobileCookie) {
    $.log("\nğŸ“± å¼€å§‹ç§»åŠ¨ç«¯æœç´¢...");
    taskResults.mobile = await executeSearch('mobile');
    totalPoints += taskResults.mobile;
  }
  
  if (config.pcCookie) {
    $.log("\nğŸ”µ å¼€å§‹Edgeç«¯æœç´¢...");
    taskResults.edge = await executeSearch('edge');
    totalPoints += taskResults.edge;
  }
  
  // ä¿å­˜çŠ¶æ€å’Œæ˜¾ç¤ºç»“æœ
  saveExecutionState();
  await showFinalResults(taskResults, totalPoints);
}

function checkResetCondition() {
  const now = new Date();
  const currentHour = now.getHours();
  const lastExecDate = $.getVal(STATE.LAST_EXEC_DATE);
  
  // å¦‚æœæ˜¯é‡ç½®æ—¶é—´åä¸”ä»Šå¤©æœªæ‰§è¡Œè¿‡
  if (currentHour >= config.resetHours && lastExecDate !== todayString) {
    $.log("ğŸ”„ æ£€æµ‹åˆ°é‡ç½®æ—¶é—´ï¼Œæ¸…é™¤æ˜¨æ—¥çŠ¶æ€");
    resetDailyState();
    return true;
  }
  
  // å¦‚æœä»Šå¤©å·²ç»æ‰§è¡Œè¿‡
  if (lastExecDate === todayString) {
    return false;
  }
  
  // é¦–æ¬¡æ‰§è¡Œæˆ–æ–°çš„ä¸€å¤©
  return true;
}

function resetDailyState() {
  $.setVal("0", STATE.PC_SEARCH_TODAY);
  $.setVal("0", STATE.MOBILE_SEARCH_TODAY);
  $.setVal("0", STATE.EDGE_SEARCH_TODAY);
}

function saveExecutionState() {
  $.setVal(todayString, STATE.LAST_EXEC_DATE);
  $.setVal(searchState.pc.count.toString(), STATE.PC_SEARCH_TODAY);
  $.setVal(searchState.mobile.count.toString(), STATE.MOBILE_SEARCH_TODAY);
  $.setVal(searchState.edge.count.toString(), STATE.EDGE_SEARCH_TODAY);
}

async function executePointTasks() {
  let earnedPoints = 0;
  
  try {
    const dashboard = await getDashboard();
    if (!dashboard?.dashboard) {
      $.log("âŒ æ— æ³•è·å–ç§¯åˆ†é¢æ¿");
      return 0;
    }
    
    const tasks = getAvailableTasks(dashboard);
    $.log(`ğŸ“‹ å‘ç° ${tasks.length} ä¸ªå¯ç”¨ä»»åŠ¡`);
    
    for (const task of tasks) {
      const result = await processTask(task, dashboard.rvt);
      if (result.success) {
        earnedPoints += result.points;
        $.log(`âœ… å®Œæˆä»»åŠ¡: ${task.title} +${result.points}åˆ†`);
      }
      await $.sleep(2000 + Math.random() * 2000);
    }
  } catch (e) {
    $.log("âŒ ç§¯åˆ†ä»»åŠ¡æ‰§è¡Œå¤±è´¥:", e);
  }
  
  return earnedPoints;
}

function getAvailableTasks(dashboard) {
  const tasks = [];
  const promotions = [...(dashboard.dashboard.morePromotions || [])];
  
  if (dashboard.dashboard.promotionalItem) {
    promotions.push(dashboard.dashboard.promotionalItem);
  }
  
  for (const task of promotions) {
    if (task.complete === false && task.pointProgressMax > 0) {
      tasks.push({
        title: task.attributes?.title || "æœªçŸ¥ä»»åŠ¡",
        points: task.pointProgressMax,
        type: task.attributes?.type,
        name: task.name,
        hash: task.hash
      });
    }
  }
  
  return tasks;
}

async function processTask(task, rvt) {
  if (task.type === "urlreward") {
    const success = await reportActivity(task, rvt);
    return {
      success: success,
      points: success ? task.points : 0
    };
  }
  
  $.log(`â­ï¸ è·³è¿‡ä»»åŠ¡ç±»å‹: ${task.type}`);
  return { success: false, points: 0 };
}

async function executeSearch(deviceType) {
  const state = searchState[deviceType];
  if (state.count >= state.total) {
    $.log(`âœ… ${getDeviceName(deviceType)}æœç´¢å·²å®Œæˆ`);
    return 0;
  }
  
  const remaining = state.total - state.count;
  $.log(`ğŸ” å¼€å§‹${getDeviceName(deviceType)}æœç´¢ï¼Œå‰©ä½™${remaining}æ¬¡`);
  
  let successCount = 0;
  
  for (let i = 0; i < remaining; i++) {
    const success = await performSingleSearch(deviceType, state.count + i + 1);
    if (success) {
      successCount++;
      state.count++;
    }
    
    if (i < remaining - 1) {
      await $.sleep(config.searchInterval * 1000);
    }
  }
  
  const pointsEarned = Math.floor(successCount / 3) * 8; // ä¼°ç®—ç§¯åˆ†
  $.log(`ğŸ‰ ${getDeviceName(deviceType)}æœç´¢å®Œæˆ: æˆåŠŸ${successCount}æ¬¡ï¼Œè·å¾—çº¦${pointsEarned}åˆ†`);
  
  return pointsEarned;
}

function getDeviceName(deviceType) {
  const names = {
    'pc': 'PCç«¯',
    'mobile': 'ç§»åŠ¨ç«¯', 
    'edge': 'Edgeç«¯'
  };
  return names[deviceType] || deviceType;
}

async function performSingleSearch(deviceType, round) {
  const baseUrl = config.useCnDomain ? "https://cn.bing.com" : "https://www.bing.com";
  const randomWord = generateSearchKeyword();
  const searchUrl = `${baseUrl}/search?q=${encodeURIComponent(randomWord)}&form=QBLH&qs=n`;
  
  const headers = getSearchHeaders(deviceType);
  
  try {
    const response = await $.http.get({
      url: searchUrl,
      headers: headers,
      timeout: 10000
    });
    
    if (response.status === 200) {
      if (config.enableDebug) {
        $.log(`âœ… ${getDeviceName(deviceType)}ç¬¬${round}æ¬¡æœç´¢æˆåŠŸ`);
      }
      return true;
    } else {
      $.log(`âŒ ${getDeviceName(deviceType)}æœç´¢å¤±è´¥ï¼ŒçŠ¶æ€ç : ${response.status}`);
      return false;
    }
  } catch (error) {
    $.log(`ğŸ’¥ ${getDeviceName(deviceType)}æœç´¢å¼‚å¸¸: ${error.message}`);
    return false;
  }
}

function getSearchHeaders(deviceType) {
  const baseHeaders = {
    "accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
    "accept-language": "zh-CN,zh;q=0.9,en;q=0.8",
    "cache-control": "no-cache",
    "pragma": "no-cache"
  };
  
  const deviceConfigs = {
    'pc': {
      "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
      "cookie": config.pcCookie
    },
    'mobile': {
      "user-agent": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_3 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.3 Mobile/15E148 Safari/604.1",
      "cookie": config.mobileCookie
    },
    'edge': {
      "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Edg/120.0.0.0",
      "cookie": config.pcCookie
    }
  };
  
  return { ...baseHeaders, ...deviceConfigs[deviceType] };
}

function generateSearchKeyword() {
  const prefixes = ['ä»€ä¹ˆæ˜¯', 'å¦‚ä½•', 'ä¸ºä»€ä¹ˆ', 'æœ€å¥½çš„', 'æœ€æ–°çš„', 'å­¦ä¹ ', 'äº†è§£'];
  const topics = ['äººå·¥æ™ºèƒ½', 'æœºå™¨å­¦ä¹ ', 'ç¼–ç¨‹', 'ç§‘æŠ€', 'å¥åº·', 'æ—…æ¸¸', 'ç¾é£Ÿ', 'éŸ³ä¹'];
  const suffixes = ['çš„æ–¹æ³•', 'çš„æŠ€å·§', 'çš„åŸç†', 'çš„å‘å±•', 'çš„åº”ç”¨'];
  
  const prefix = prefixes[Math.floor(Math.random() * prefixes.length)];
  const topic = topics[Math.floor(Math.random() * topics.length)];
  const suffix = Math.random() > 0.5 ? suffixes[Math.floor(Math.random() * suffixes.length)] : '';
  const randomNum = Math.floor(Math.random() * 1000);
  
  return `${prefix}${topic}${suffix} ${randomNum}`;
}

async function getDashboard() {
  if (!config.pointCookie) return null;
  
  const headers = {
    "authority": 'rewards.bing.com',
    "accept": 'application/json, text/javascript, */*; q=0.01',
    "cookie": config.pointCookie,
    "user-agent": 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
  };
  
  try {
    const response = await $.http.get({
      url: `https://rewards.bing.com/?_=${Date.now()}`,
      headers: headers
    });
    
    if (response.status === 200) {
      const data = response.body;
      const rvtMatch = data.match(/__RequestVerificationToken.*?value="([^"]*)"/);
      const dashboardMatch = data.match(/var dashboard = ({[^;]*});/);
      
      if (rvtMatch && dashboardMatch) {
        return {
          dashboard: JSON.parse(dashboardMatch[1]),
          rvt: rvtMatch[1]
        };
      }
    }
  } catch (e) {
    $.log("âŒ è·å–ç§¯åˆ†é¢æ¿å¤±è´¥");
  }
  
  return null;
}

async function reportActivity(task, rvt) {
  const headers = {
    "authority": 'rewards.bing.com',
    "content-type": 'application/x-www-form-urlencoded',
    "cookie": config.pointCookie,
    "x-requested-with": 'XMLHttpRequest'
  };
  
  const body = `id=${task.name}&hash=${task.hash}&timeZone=480&activityAmount=1&__RequestVerificationToken=${rvt}`;
  
  try {
    const response = await $.http.post({
      url: `https://rewards.bing.com/api/reportactivity?_=${Date.now()}`,
      headers: headers,
      body: body
    });
    
    return response.status === 200;
  } catch (e) {
    return false;
  }
}

async function showCurrentPoints() {
  const dashboard = await getDashboard();
  if (dashboard?.dashboard) {
    const points = dashboard.dashboard.userStatus?.availablePoints || "æœªçŸ¥";
    $.msg(
      "Bingç§¯åˆ†çŠ¶æ€",
      `å½“å‰ç§¯åˆ†: ${points}`,
      "ä»Šæ—¥ä»»åŠ¡å·²å®Œæˆ"
    );
  }
}

async function showFinalResults(results, totalPoints) {
  const dashboard = await getDashboard();
  const currentPoints = dashboard?.dashboard?.userStatus?.availablePoints || "æœªçŸ¥";
  
  $.setVal(currentPoints, STATE.CACHE_POINTS);
  
  const message = `
ä»»åŠ¡ç§¯åˆ†: ${results.points}åˆ†
PCæœç´¢: ${results.pc}åˆ†  
ç§»åŠ¨æœç´¢: ${results.mobile}åˆ†
Edgeæœç´¢: ${results.edge}åˆ†
æ€»è®¡è·å¾—: ${totalPoints}åˆ†
å½“å‰ç§¯åˆ†: ${currentPoints}
  `.trim();
  
  $.msg("Bingç§¯åˆ†ä»»åŠ¡å®Œæˆ", message);
}

function getCookie() {
  if ($.isMatch(/\/rewards\.bing\.com/)) {
    $.log("ğŸª å¼€å§‹è·å–Cookie");
    try {
      const cookieHeader = $request.headers?.Cookie || $request.headers?.cookie;
      if (cookieHeader) {
        $.setVal(CONFIG.POINT_COOKIE, cookieHeader);
        $.appendNotifyInfo('âœ… æˆåŠŸè·å–ç§¯åˆ†Cookie');
      }
    } catch (e) {
      $.appendNotifyInfo('âŒ è·å–Cookieå¤±è´¥');
    }
  }
}

// ç®€åŒ–çš„Toolkitç±»å®ç°
function Toolkit(name, id, options) {
  return new class {
    constructor(name, id, options) {
      this.name = name;
      this.id = id;
      this.options = options || {};
      this.logs = [];
      this.startTime = Date.now();
      this.log("", `ğŸ”” ${this.name} å¼€å§‹æ‰§è¡Œ`);
    }
    
    log(...args) {
      const message = args.join(" ");
      this.logs.push(message);
      console.log(message);
    }
    
    getVal(key, defaultValue = "") {
      // å®é™…ç¯å¢ƒä¸­è¿™é‡Œä¼šè°ƒç”¨å¯¹åº”çš„æŒä¹…åŒ–å­˜å‚¨API
      if (typeof $persistentStore !== 'undefined') {
        return $persistentStore.read(key) || defaultValue;
      }
      if (typeof $prefs !== 'undefined') {
        return $prefs.valueForKey(key) || defaultValue;
      }
      return defaultValue;
    }
    
    setVal(value, key) {
      // å®é™…ç¯å¢ƒä¸­è¿™é‡Œä¼šè°ƒç”¨å¯¹åº”çš„æŒä¹…åŒ–å­˜å‚¨API
      if (typeof $persistentStore !== 'undefined') {
        return $persistentStore.write(value, key);
      }
      if (typeof $prefs !== 'undefined') {
        return $prefs.setValueForKey(value, key);
      }
      return true;
    }
    
    msg(title, subtitle, body) {
      if (typeof $notification !== 'undefined') {
        $notification.post(title, subtitle, body);
      }
    }
    
    async sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    done() {
      const cost = (Date.now() - this.startTime) / 1000;
      this.log("", `ğŸ”” ${this.name} æ‰§è¡Œå®Œæˆ ğŸ•› ${cost.toFixed(3)}ç§’`);
      if (typeof $done !== 'undefined') $done();
    }
    
    isRequest() {
      return typeof $request !== 'undefined';
    }
    
    isMatch(pattern) {
      return this.isRequest() && $request.url?.match(pattern);
    }
    
    formatDate(date, fmt) {
      const o = {
        "M+": date.getMonth() + 1,
        "d+": date.getDate(),
        "H+": date.getHours(),
        "m+": date.getMinutes(), 
        "s+": date.getSeconds(),
        "q+": Math.floor((date.getMonth() + 3) / 3),
        "S": date.getMilliseconds()
      };
      if (/(y+)/.test(fmt)) {
        fmt = fmt.replace(RegExp.$1, (date.getFullYear() + "").substr(4 - RegExp.$1.length));
      }
      for (const k in o) {
        if (new RegExp("(" + k + ")").test(fmt)) {
          fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : (("00" + o[k]).substr(("" + o[k]).length)));
        }
      }
      return fmt;
    }
    
    boxJsJsonBuilder(config, info) {
      // BoxJSé…ç½®æ„å»ºé€»è¾‘
      this.log("ğŸ“¦ BoxJSé…ç½®å·²æ›´æ–°");
    }
    
    get isExecComm() {
      return false;
    }
    
    appendNotifyInfo(message) {
      this.log(message);
    }
    
    // HTTPè¯·æ±‚æ–¹æ³•
    http = {
      get: (options) => {
        return new Promise((resolve) => {
          if (typeof $httpClient !== 'undefined') {
            $httpClient.get(options, (error, response, body) => {
              resolve({ error, status: response?.status, body });
            });
          } else if (typeof $task !== 'undefined') {
            $task.fetch(options).then(response => {
              resolve({ error: null, status: response.statusCode, body: response.body });
            }, error => {
              resolve({ error, status: null, body: null });
            });
          } else {
            resolve({ error: "No HTTP client", status: null, body: null });
          }
        });
      },
      
      post: (options) => {
        return new Promise((resolve) => {
          if (typeof $httpClient !== 'undefined') {
            $httpClient.post(options, (error, response, body) => {
              resolve({ error, status: response?.status, body });
            });
          } else if (typeof $task !== 'undefined') {
            options.method = 'POST';
            $task.fetch(options).then(response => {
              resolve({ error: null, status: response.statusCode, body: response.body });
            }, error => {
              resolve({ error, status: null, body: null });
            });
          } else {
            resolve({ error: "No HTTP client", status: null, body: null });
          }
        });
      }
    };
  }(name, id, options);
}